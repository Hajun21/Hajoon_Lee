//#include <stdio.h>
//int main() {
//	int n1;	
//
//	n1 = 10;	
//
//	printf("%d\n", n1);	 
//
//	int n2 = 20;	
//	
//	printf("%d\n", n1 + n2);
//
//	return 0;
//}

//#include <stdio.h>
//int main() {
//	int num1;	
//	int num2;
//	int num3;
//	int num4;
//
//	num1 = 10;
//	num2 = 20;
//	num3 = num1 + num2;
//	num4 = num2 - num1;
//
//	printf("%d\n", num3);	 
//	printf("%d\n", num4);
//
//	return 0;
//}

////#include <stdio.h>
//	int main() 
//	{
//	char ch1 = 'a';
//	char ch2 = 97;					//011000001
//	char ch3 = 0b1100001;			// 2진법
//	char ch4 = '!';
//
//	printf("ch1 = %c\n", ch1);		//  %c : 문자를 받는다.
//	printf("ch2 = %c\n", ch2);
//	printf("ch3 = %c\n", ch3);
//	printf("ch4 = %d\n", ch4);
//	return 0;
//	}              // C언어는 ASCII 코드표를 이용한다. 문자 or 숫자 든 간에 전부 비트열로 저장된다.

%d: 10진수(정수형)
%f: 실수형
%e: 지수형
%o: 8진수
%x: 16진수
%u: 부호없는 10진수
%g: 실수형 자동출력
%p: 포인터의 주소
%c: 하나의 문자로 출력
%s: 문자열

1) 음수 계산(2의 보수)  [1 비트] ///128
 00000101 = 5

 음수 계산 → 0을 1로 1를 0으로 and +1

 11111010 → +1   → 11111011

 11111011 = -5 (2의 보수로 구한다.)

2 의 보수 표현 체계 하에서 어떤 수의 부호를 바꾸려면 먼저 비트를 반전 시킨 뒤에 1 을 더하면 됩니다.

ex) -7 을 나타내기 위해서는, 7 의 이진수 표현인 `0111` 의 비트를 모두 반전시키면 `1000` 이 되는데 여기다 1 을 더해서 `1001` 로 표현하면 됩니다. 
반대로 -7 에서 7 로 가고 싶다면 `1001` 의 부호를 모두 반전 시킨뒤 (0110) 다시 1 을 더하면 양수인 7 (0111) 이 나오게 됩니다.
이 체계에서 중요한 점은 `0000` 의 2 의 보수는 그대로 `0000` 이 된다는 점입니다. 왜냐하면 `0000` 을 반전하면 `1111` 이 되는데, 다시 1 을 더하면 `0000` 이 되기 때문이죠!
또한 어떤 수가 음수 인지 양수인지 판단하는 방법도 매우 쉽습니다. 그냥 맨 앞 비트가 부호 비트라고 생각하면 됩니다. 예를 들어서 `1101` 의 경우 맨 앞 비트가 1 이기 때문에 음수 입니다. 
따라서 이 수가 어떤 값인지 알고싶다면 보수를 구한 뒤에 (1101 --> 0010 --> 0011) - 만 붙여주면 되겠죠. `0011` 이 3 이므로, `1101` 은 경우 -3 이 됩니다.

03 실수의 처리방식
소수점 이하 수(가수부)를 포함하는 수
실수의 가수부에 대한 범위는 무한대에 가깝기 때문에
컴퓨터의 메모리 공간에 소수점 이하의 수 범위를 다 담아내지 못한다.
따라서 소수점이 00 자리까지만 유효범위로 정하여 실수값을 저장하기 때문에
실수값은 오차가 발생할 수 밖에 없다.

실수값의 소수점의 위치를 지정하는 방식은
고정소수점 방식과 부동소수점 방식이 있다

고정 소수점 : 소수점의 위치가 미리 고정
부동 소수점 : 삽입되는 데이터값에 따라 소수점위치가 변경

05 자료형 & 변수

자료형 : Data 저장을 위해 미리 예약된 예약어
(정수) 자료형 ------------
int : 4byte 정수  1비트 -> 4byte          // 8 x 4 = 32		 실제 비트 수 31
char : 1byte
short : 2byte
long long : 8byte

(실수) 자료형 -------------
double : 8byte
float : 4byte

#include <stdio.h>
int main()
{
	int n1;						// 변수 선언 : 4byte 정수공간형성 n1 이름 부여

	n1 = 10;					 // 변수 공간에 값 대입
								// =(대입연산자) 공간 = 값 (먼저 처리)
								// 10이라는 Data 값을 먼저 저장한 뒤
								// n1 공간에 복사(대입) 변수는 하나의 숫자만 가능
	printf("%d\n", n1);		// 변수 서식문자에 맞게 출력
								// n1 안의 값을 %d에 맞게 출력

	int n2 = 20;				//변수 초기화
								// 20의 값을 상수 pool에 저장한 이후
								// 4byte 정수공간형성 후 n2 이름을 붙이고 초기화

	printf("%d\n", n1 + n2);		// n1안의 값 + n2안의 값 %d 서식에 출력
}

 05 정수 자료형

#include <stdio.h>

{
	char n1 = 10;    // 자료형 불일치 : char 타입은 문자를 받기위해 존재한다.
	short n2 = 20;	// 자료형 불일치 : short 타입도 문자를 받기위해 존재한다.
	int n3 = 30;		// 자료형 일치
}

 06 실수 자료형

#include <stdio.h>
int main ()
{
	float var1 = 0.33333333333F;
	double var2 = 0.333333333333333;

	printf("%.20f\n", var1);			// .20f : 20번 자리까지 출력해라
	printf("%.20f\n", var2);
}

 07 단일 문자 자료형

 단일 문자 저장을 위해서 약속된 코드표를 참고하여
 해당 코드표에 지정된 비트열로 저장시킨다.
 C언어는 ASCII 코드표를 이용한다.
 문자 or 숫자 든간에 전부 비트열로 저장된다.


 08 문자열 저장(배열)

 단일문자 : 'a'
 문자열 : "hello" ->	h e l l o 0	(6byte 필요 : null 문자)
 중요!! : 문자열은 마지막에 NULL문자 (\0)를 반드시 포함
 배열 : 같은 자료형으로 연속적인 공간 형성
 char arr [3] -> char 크기를 요소로 3칸짜리 공간을 형성
